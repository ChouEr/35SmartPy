#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <termios.h>
#include "uart.h"
#include "uartdata.h"
#include "queue.h"
#include <string.h>


CAN_OBJ canRead[50];//设置足够大小接收数据
CAN_OBJ canSend[3];//每次发送3帧数据
int readGun;
int readBrake;
int readSteer;
int sendGun;
int sendBrake;
int sendSteer;
void *send( void *ptr );
void *rRead( void *ptr );
void *monitor( void *ptr );
void initMsg();
void initVar();

int gunRead[8];
int* gun_read = gunRead;
extern  int *read_gun(){
    while(!readGun){}
    return gun_read;
}
int brakeRead[8];
int* brake_read = brakeRead;
extern int *read_brake(){
    while(!readBrake){}
    return brake_read;
}
int steerRead[8];
int* steer_read = steerRead;
extern int *read_steer(){
    while(!readSteer){}
    return steer_read;
}
extern void send_gun(int control_mode, int control_depth){
    sendGun = 0;
    canSend[0].Data[0] = control_mode;
    canSend[0].Data[1] = control_depth;
    sendGun = 1;
}

extern void send_brake(int control_mode, int control_depth){
    sendBrake= 0;
    canSend[1].Data[0] = control_mode;
    canSend[1].Data[1] = control_depth;
    sendBrake = 1;
}

extern void send_steer(int control_mode, int angle, int calib){
    sendSteer= 0;
    canSend[2].Data[0] = control_mode;
    //canSend[2].Data[1] = control_depth;
    sendSteer = 1;
}

extern void init()
{
    fprintf(stderr,"Yea!!!- pthread_create() return code: \n");
    QueueInit();
    MCUUartInit();
    MCUUartListen();

    InitCANOBJ(canRead,50);
    InitCANOBJ(canSend,3);
    initMsg();

    pthread_t thread_send, thread_read, thread_monitor;
    const char *send_msg= "Thread send";
    const char *read_msg = "Thread read";
    const char *monitor_msg = "Thread monitor";
    int  iret_send, iret_read, iret_monitor;

    /* Create independent threads each of which will execute function */

    iret_send = pthread_create( &thread_send, NULL, send, (void*) send_msg);
    if(iret_send)
    {
        fprintf(stderr,"Error - pthread_create() return code: %d\n",iret_send);
        exit(EXIT_FAILURE);
    }
    printf("pthread_create() for thread 1 returns: %d\n",iret_send);

    iret_read = pthread_create( &thread_read, NULL, rRead, (void*) read_msg);
    if(iret_read)
    {
        fprintf(stderr,"Error - pthread_create() return code: %d\n",iret_read);
        exit(EXIT_FAILURE);
    }
    printf("pthread_create() for thread 1 returns: %d\n",iret_read);

    iret_monitor = pthread_create( &thread_monitor, NULL, monitor, (void*) monitor_msg);
    if(iret_read)
    {
        fprintf(stderr,"Error - pthread_create() return code: %d\n",iret_monitor);
        exit(EXIT_FAILURE);
    }
    printf("pthread_create() for thread 1 returns: %d\n",iret_monitor);

    /* Wait till threads are complete before main continues. Unless we  */
    /* wait we run the risk of executing an exit which will terminate   */
    /* the process and all threads before the threads have completed.   */

    pthread_join( thread_send, NULL);
    pthread_join( thread_read, NULL); 
    pthread_join( thread_monitor, NULL); 

    exit(EXIT_SUCCESS);
}
void *rRead( void *ptr )
{
    char *message;
    message = (char *) ptr;
    printf("%s \n", message);
    int ii=0;
    printf("start reading from CAN.........\n");
    while (ii < 99){
        ii++;
        int canLen=GetReceiveCanNum(can250);
        while(canLen < 0){;}
        GetReceiveCanData(can250, canRead, canLen);
        printf("CAN read length is : %d\n",canLen);
        for(int j=0; j< canLen; j++){
            printf(" %d th CANID is %d",j,canRead[j].ID);
            if(canRead[j].ID == 0x199){
                readGun = 0;
                gun_read[0] = canRead[j].Data[0];
                gun_read[1] = canRead[j].Data[1];
                gun_read[2] = canRead[j].Data[2];
                gun_read[3] = canRead[j].Data[3];
                readGun = 1;
            }
            if(canRead[j].ID == 0x100){
                readBrake = 0;
                brake_read[0] = canRead[j].Data[0];
                brake_read[1] = canRead[j].Data[1];
                brake_read[2] = canRead[j].Data[2];
                brake_read[3] = canRead[j].Data[3];
                brake_read[4] = canRead[j].Data[4];
                brake_read[5] = canRead[j].Data[5];
                brake_read[6] = canRead[j].Data[6];
                brake_read[7] = canRead[j].Data[7];
                readBrake = 1;
            }
            if(canRead[j].ID == 0x401){
                readSteer= 0;
                steer_read[0] = canRead[j].Data[0];
                steer_read[1] = canRead[j].Data[1];
                steer_read[2] = canRead[j].Data[2];
                steer_read[3] = canRead[j].Data[3];
                steer_read[4] = canRead[j].Data[4];
                steer_read[5] = canRead[j].Data[5];
                steer_read[6] = canRead[j].Data[6];
                steer_read[7] = canRead[j].Data[7];
                readSteer = 1;
            }

        }
        sleep(10);
    }
}

void initVar(){
    readGun =0;
    readBrake = 0;
    readSteer = 0;
    sendGun = 0;
    sendBrake = 0;
    sendSteer = 0;
}



void *send( void *ptr )
{
    char *message;
    message = (char *) ptr;
    printf("%s \n", message);
    int ii=0;
    while (ii < 99){
        ii++;
        while(!sendSteer || !sendBrake || !sendGun){}
        SendCanData(can250,canSend,3);//发送帧
        sleep(50);
    }
}

void initMsg(){
    //gun
    canSend[0].ID = 0x200;
    canSend[0].RemoteFlag = 0;
    canSend[0].ExternFlag = 0;
    canSend[0].DataLen = 8;
    canSend[0].Data[0]=0x00;//智能控制数据发送
    canSend[0].Data[1]=0x00;
    canSend[0].Data[2]=0x00;
    canSend[0].Data[3]=0x00;
    canSend[0].Data[4]=0x00;
    canSend[0].Data[5]=0x00;
    canSend[0].Data[6]=0x00;
    //Brake
    canSend[1].ID = 0x99;
    canSend[1].RemoteFlag = 0;
    canSend[1].ExternFlag = 0;
    canSend[1].DataLen = 8;
    canSend[1].Data[0]=0x40;//智能控制数据发送
    canSend[1].Data[1]=0x03;
    canSend[1].Data[2]=0x2;
    canSend[1].Data[3]=0;
    canSend[1].Data[4]=0;
    canSend[1].Data[5]=0;
    canSend[1].Data[6]=0;

    //Steer
    canSend[2].ID = 0x469;
    canSend[2].RemoteFlag = 0;
    canSend[2].ExternFlag = 0;
    canSend[2].DataLen = 8;
    canSend[2].Data[0]=0x00;//智能控制数据发送
    canSend[2].Data[1]=0x00;
    canSend[2].Data[2]=0x0;
    canSend[2].Data[3]=0x00;
    canSend[2].Data[4]=0x00;
    canSend[2].Data[5]=0x00;
    canSend[2].Data[6]=0x00; 
    canSend[2].Data[7]= canSend[2].Data[0] ^ canSend[2].Data[1] ^canSend[2].Data[2] ^canSend[2].Data[3] ^canSend[2].Data[4] ^canSend[2].Data[5] ^canSend[2].Data[6];
    sleep(50);
}

void *monitor(void *ptr){

}
int main(){
    return 0;
}
